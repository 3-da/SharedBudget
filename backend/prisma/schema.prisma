generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prisma"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
}

//#region DTO Generators ####################################################################################################

// -------------------------------------------------
// DTO Generator for NestJS Backend
// Generates: Entity classes, CreateDto, UpdateDto
// with class-validator decorators + Swagger annotations
// Install first: npm install prisma-generator-nestjs-dto
// Prisma generators are great at creating DTOs that mirror your data model (CRUD shapes).
// But your API often needs custom action DTOs and response DTOs
// -------------------------------------------------

generator nestjsDto {
  provider                        = "prisma-generator-nestjs-dto"
  output                          = "../src/generated/dto"
  prismaClientImportPath          = "../../prisma/client.js"
  outputToNestJsResourceStructure = "true"
  flatResourceStructure           = "true"
  exportRelationModifierClasses   = "true"
  reExport                        = "true"
  generateFileTypes               = "all"
  createDtoPrefix                 = "Create"
  updateDtoPrefix                 = "Update"
  dtoSuffix                       = "Dto"
  entityPrefix                    = ""
  entitySuffix                    = ""
  classValidation                 = "true"
  fileNamingStyle                 = "kebab"
  noDependencies                  = "false"
  outputType                      = "class"
  definiteAssignmentAssertion     = "false"
  requiredResponseApiProperty     = "true"
  prettier                        = "true"
  wrapRelationsAsType             = "false"
  showDefaultValues               = "false"
}

// -------------------------------------------------
// Type Generator for React Frontend
// Generates: Plain TypeScript interfaces (no decorators)
// Zero backend dependencies â€” safe for browser bundle
// -------------------------------------------------
// generator reactTypes {
//   provider                        = "prisma-generator-nestjs-dto"
//   output                          = "../../frontend/src/types/generated"
//   prismaClientImportPath          = "@prisma/client"
//   outputToNestJsResourceStructure = "false"
//   flatResourceStructure           = "true"
//   exportRelationModifierClasses   = "false"
//   reExport                        = "true"
//   generateFileTypes               = "all"
//   createDtoPrefix                 = "Create"
//   updateDtoPrefix                 = "Update"
//   dtoSuffix                       = "Dto"
//   entityPrefix                    = ""
//   entitySuffix                    = ""
//   classValidation                 = "false"
//   fileNamingStyle                 = "kebab"
//   noDependencies                  = "true"
//   outputType                      = "interface"
//   definiteAssignmentAssertion     = "false"
//   requiredResponseApiProperty     = "false"
//   prettier                        = "true"
//   wrapRelationsAsType             = "false"
//   showDefaultValues               = "false"
// }

//#endregion ####################################################################################################

//#region Enums ####################################################################################################

enum HouseholdRole {
  OWNER
  MEMBER
}

enum ExpenseType {
  PERSONAL
  SHARED
}

enum ExpenseCategory {
  RECURRING
  ONE_TIME
}

enum ExpenseFrequency {
  MONTHLY
  YEARLY
}

enum YearlyPaymentStrategy {
  FULL
  INSTALLMENTS
}

enum InstallmentFrequency {
  MONTHLY // 12 payments per year
  QUARTERLY // 4 payments: Jan, Apr, Jul, Oct
  SEMI_ANNUAL // 2 payments: Jan & Jul
}

enum ApprovalAction {
  CREATE
  UPDATE
  DELETE
}

enum ApprovalStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

//#endregion ####################################################################################################

//#region Models ####################################################################################################

model User {
  id            String    @id @default(uuid())
  /// User email address
  /// @example user@example.com
  /// @IsEmail()
  email         String    @unique
  /// @DtoEntityHidden
  password      String
  /// User's first name
  /// @example John
  /// @minLength 1
  /// @maxLength 50
  /// @MinLength(1)
  /// @MaxLength(50)
  firstName     String
  /// User's last name
  /// @example Doe
  /// @minLength 1
  /// @maxLength 50
  /// @MinLength(1)
  /// @MaxLength(50)
  lastName      String
  /// Whether the user's email has been verified
  /// @DtoReadOnly
  emailVerified Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  /// @DtoReadOnly
  /// @DtoEntityHidden
  deletedAt     DateTime?

  householdMember    HouseholdMember?
  salaries           Salary[]
  createdExpenses    Expense[]         @relation("ExpenseCreator")
  paidExpenses       Expense[]         @relation("ExpensePayer")
  requestedApprovals ExpenseApproval[] @relation("ApprovalRequester")
  reviewedApprovals  ExpenseApproval[] @relation("ApprovalReviewer")
  sentInvitations     HouseholdInvitation[] @relation("InvitationSender")
  receivedInvitations HouseholdInvitation[] @relation("InvitationTarget")

  @@map("users")
}

model Household {
  id         String   @id @default(uuid())
  /// Name of the household
  /// @example My Home
  /// @minLength 1
  /// @maxLength 50
  /// @MinLength(1)
  /// @MaxLength(50)
  name       String
  /// Unique invite code for joining the household
  /// @example a1b2c3d4
  /// @DtoReadOnly
  inviteCode String   @unique
  /// Maximum number of members allowed
  /// @example 2
  /// @DtoReadOnly
  maxMembers Int      @default(2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  members   HouseholdMember[]
  salaries  Salary[]
  expenses  Expense[]
  approvals ExpenseApproval[]
  invitations HouseholdInvitation[]

  @@map("households")
}

model HouseholdMember {
  id          String        @id @default(uuid())
  /// ID of the member user
  /// @example 550e8400-e29b-41d4-a716-446655440000
  userId      String        @unique
  /// ID of the household
  /// @example 660e8400-e29b-41d4-a716-446655440000
  householdId String
  /// Role of the member in the household
  /// @DtoReadOnly
  role        HouseholdRole @default(MEMBER)
  /// When the member joined
  joinedAt    DateTime      @default(now())

  user      User      @relation(fields: [userId], references: [id])
  household Household @relation(fields: [householdId], references: [id])

  @@unique([userId, householdId])
  @@index([householdId])
  @@map("household_members")
}

model HouseholdInvitation {
  id           String           @id @default(uuid())
  /// Current status
  /// @DtoReadOnly
  status       InvitationStatus @default(PENDING)
  /// Household this invitation is for
  householdId  String
  /// User who sent the invitation (the household owner)
  senderId     String
  /// User who was invited and must respond
  targetUserId String
  createdAt    DateTime         @default(now())
  /// When the target user responded
  respondedAt  DateTime?

  household  Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  sender     User      @relation("InvitationSender", fields: [senderId], references: [id])
  targetUser User      @relation("InvitationTarget", fields: [targetUserId], references: [id])

  @@index([targetUserId, status])
  @@index([householdId, status])
  @@index([senderId])
  @@map("household_invitations")
}

model Salary {
  id            String   @id @default(uuid())
  /// @DtoReadOnly
  userId        String
  /// @DtoReadOnly
  householdId   String
  /// Baseline monthly salary
  /// @example 3500.00
  /// @minimum 0
  defaultAmount Decimal  @db.Decimal(12, 2)
  /// Actual salary this month
  /// @example 3500.00
  /// @minimum 0
  currentAmount Decimal  @db.Decimal(12, 2)
  /// Month (1-12)
  /// @example 6
  /// @minimum 1
  /// @maximum 12
  /// @Min(1)
  /// @Max(12)
  month         Int
  /// Year (validated to current year in service)
  /// @example 2026
  year          Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id])
  household Household @relation(fields: [householdId], references: [id])

  @@unique([userId, month, year])
  @@index([householdId])
  @@map("salaries")
}

model Expense {
  id                    String                 @id @default(uuid())
  /// @DtoReadOnly
  householdId           String
  /// @DtoReadOnly
  createdById           String
  /// Expense name
  /// @example Monthly Rent
  /// @minLength 1
  /// @maxLength 100
  /// @MinLength(1)
  /// @MaxLength(100)
  name                  String                 @db.VarChar(100)
  /// Total amount in EUR
  /// @example 500.00
  /// @minimum 0
  amount                Decimal                @db.Decimal(12, 2)
  /// PERSONAL or SHARED
  type                  ExpenseType
  /// RECURRING or ONE_TIME
  category              ExpenseCategory
  /// MONTHLY or YEARLY
  frequency             ExpenseFrequency
  /// FULL or INSTALLMENTS (null if monthly)
  yearlyPaymentStrategy YearlyPaymentStrategy?
  /// Installment payment frequency
  installmentFrequency  InstallmentFrequency?
  /// Month to pay in full (1-12, null if not FULL strategy)
  /// @minimum 1
  /// @maximum 12
  paymentMonth          Int?
  /// User who pays. Null means split equally among members
  paidByUserId          String?
  /// For ONE_TIME expenses: which month (1-12)
  /// @minimum 1
  /// @maximum 12
  month                 Int?
  /// For ONE_TIME expenses: which year (validated in service)
  /// @example 2026
  year                  Int?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  /// @DtoReadOnly
  /// @DtoEntityHidden
  deletedAt             DateTime?

  household Household         @relation(fields: [householdId], references: [id])
  createdBy User              @relation("ExpenseCreator", fields: [createdById], references: [id])
  paidBy    User?             @relation("ExpensePayer", fields: [paidByUserId], references: [id])
  approvals ExpenseApproval[]

  @@index([householdId, type])
  @@index([createdById])
  @@map("expenses")
}

model ExpenseApproval {
  id            String         @id @default(uuid())
  /// Associated expense (null for CREATE actions)
  expenseId     String?
  /// @DtoReadOnly
  householdId   String
  /// Action type: CREATE, UPDATE, or DELETE
  action        ApprovalAction
  /// Approval status
  /// @DtoReadOnly
  status        ApprovalStatus @default(PENDING)
  /// User who proposed the change
  /// @DtoReadOnly
  requestedById String
  /// User who reviewed the approval
  /// @DtoReadOnly
  reviewedById  String?
  /// Reviewer's comment
  /// @example Approved, looks good
  /// @maxLength 500
  /// @MaxLength(500)
  message       String?
  /// For CREATE/UPDATE: the proposed expense data
  proposedData  Json?
  createdAt     DateTime       @default(now())
  /// When the review happened
  /// @DtoCreateHidden
  reviewedAt    DateTime?

  expense     Expense?  @relation(fields: [expenseId], references: [id])
  household   Household @relation(fields: [householdId], references: [id])
  requestedBy User      @relation("ApprovalRequester", fields: [requestedById], references: [id])
  reviewedBy  User?     @relation("ApprovalReviewer", fields: [reviewedById], references: [id])

  @@index([householdId, status])
  @@index([requestedById])
  @@map("expense_approvals")
}

//#endregion ####################################################################################################
